{"version":3,"sources":["../../../../../apps/web/src/lib/security-logger.ts","../../../../../apps/web/src/lib/quest-status.ts"],"sourcesContent":["import { prisma } from \"./prisma\";\nimport { logger } from \"./logger\";\nimport crypto from \"crypto\";\nimport type { SecurityEventType } from \"@prisma/client\";\n\ninterface SecurityEventData {\n  type: SecurityEventType;\n  userId?: string;\n  email?: string;\n  ipAddress: string;\n  userAgent?: string;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Log a security event to the database\n * Automatically hashes email addresses for privacy\n * Triggers alerts for suspicious activity\n */\nexport async function logSecurityEvent(data: SecurityEventData) {\n  try {\n    // Hash email for privacy (can still correlate events without storing PII)\n    const emailHash = data.email\n      ? crypto.createHash(\"sha256\").update(data.email).digest(\"hex\")\n      : undefined;\n\n    await prisma.securityEvent.create({\n      data: {\n        type: data.type,\n        userId: data.userId,\n        ipAddress: data.ipAddress,\n        userAgent: data.userAgent,\n        metadata: {\n          ...data.metadata,\n          emailHash,\n        },\n      },\n    });\n\n    // Check for suspicious activity patterns\n    if (data.type === \"LOGIN_FAILED\") {\n      await checkFailedLoginThreshold(data.ipAddress);\n    }\n\n    if (data.type === \"RATE_LIMIT_EXCEEDED\") {\n      await checkRateLimitPattern(data.ipAddress);\n    }\n  } catch (error) {\n    // Don't fail the request if logging fails\n    logger.error(\n      { error, eventType: data.type },\n      \"Failed to log security event\"\n    );\n  }\n}\n\n/**\n * Check if an IP has exceeded the failed login threshold\n * Alert if >10 failed logins in the last hour\n */\nasync function checkFailedLoginThreshold(ipAddress: string) {\n  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n\n  const failedAttempts = await prisma.securityEvent.count({\n    where: {\n      type: \"LOGIN_FAILED\",\n      ipAddress,\n      createdAt: { gte: oneHourAgo },\n    },\n  });\n\n  if (failedAttempts >= 10) {\n    logger.warn(\n      { ipAddress, failedAttempts },\n      \"Suspicious login activity detected - possible brute force attack\"\n    );\n  }\n}\n\n/**\n * Check if an IP is repeatedly hitting rate limits\n * Alert if >5 rate limit violations in 15 minutes\n */\nasync function checkRateLimitPattern(ipAddress: string) {\n  const fifteenMinutesAgo = new Date(Date.now() - 15 * 60 * 1000);\n\n  const rateLimitHits = await prisma.securityEvent.count({\n    where: {\n      type: \"RATE_LIMIT_EXCEEDED\",\n      ipAddress,\n      createdAt: { gte: fifteenMinutesAgo },\n    },\n  });\n\n  if (rateLimitHits >= 5) {\n    logger.warn(\n      { ipAddress, rateLimitHits },\n      \"Repeated rate limit violations - possible automated attack\"\n    );\n  }\n}\n\n/**\n * Get security events for a user (for security dashboard)\n */\nexport async function getUserSecurityEvents(userId: string, limit = 50) {\n  return prisma.securityEvent.findMany({\n    where: { userId },\n    orderBy: { createdAt: \"desc\" },\n    take: limit,\n  });\n}\n\n/**\n * Get security events for an IP address (for investigation)\n */\nexport async function getIpSecurityEvents(ipAddress: string, limit = 50) {\n  return prisma.securityEvent.findMany({\n    where: { ipAddress },\n    orderBy: { createdAt: \"desc\" },\n    take: limit,\n  });\n}\n","/**\n * Quest Status Computation Utility\n *\n * Computes the effective quest status based on stored status and objective progress.\n * This is used to determine IN_PROGRESS status when some objectives are done.\n */\n\nimport type { QuestStatus } from \"@prisma/client\";\n\nexport interface ObjectiveWithProgress {\n  id: string;\n  optional: boolean;\n  count?: number | null; // Target count from Objective (for numeric objectives)\n  progress?:\n    | { completed: boolean; current?: number | null; target?: number | null }[]\n    | null;\n}\n\nexport interface ObjectiveProgressSummary {\n  total: number;\n  completed: number;\n  requiredTotal: number;\n  requiredCompleted: number;\n}\n\n/**\n * Check if an objective is complete.\n * For numeric objectives (with target), checks if current >= target.\n * For binary objectives, checks the completed flag.\n */\nexport function isObjectiveComplete(\n  progress:\n    | { completed: boolean; current?: number | null; target?: number | null }\n    | null\n    | undefined\n): boolean {\n  if (!progress) return false;\n\n  // For numeric objectives, check current >= target\n  if (\n    progress.target !== null &&\n    progress.target !== undefined &&\n    progress.target > 0\n  ) {\n    const current = progress.current ?? 0;\n    return current >= progress.target;\n  }\n\n  // For binary objectives, use the completed flag\n  return progress.completed === true;\n}\n\n/**\n * Compute objective progress summary for a quest.\n * Returns counts of total and completed objectives, separated by required vs optional.\n */\nexport function computeObjectiveProgress(\n  objectives: ObjectiveWithProgress[]\n): ObjectiveProgressSummary {\n  let total = 0;\n  let completed = 0;\n  let requiredTotal = 0;\n  let requiredCompleted = 0;\n\n  for (const obj of objectives) {\n    total++;\n    const isComplete = isObjectiveComplete(obj.progress?.[0]);\n\n    if (isComplete) {\n      completed++;\n    }\n\n    if (!obj.optional) {\n      requiredTotal++;\n      if (isComplete) {\n        requiredCompleted++;\n      }\n    }\n  }\n\n  return { total, completed, requiredTotal, requiredCompleted };\n}\n\n/**\n * Compute the effective quest status based on stored status and objective progress.\n *\n * Rules:\n * - If stored status is LOCKED, always return LOCKED (dependencies not met)\n * - If all required objectives are complete, return COMPLETED\n * - If at least one required objective is complete, return IN_PROGRESS\n * - Otherwise, return the stored status (AVAILABLE or computed default)\n *\n * @param storedStatus - The status stored in QuestProgress (or null if no progress)\n * @param objectives - Array of objectives with their progress\n * @param defaultStatus - Status to use when no progress exists (default: \"AVAILABLE\")\n */\nexport function computeQuestStatus(\n  storedStatus: QuestStatus | null,\n  objectives: ObjectiveWithProgress[],\n  defaultStatus: QuestStatus = \"AVAILABLE\"\n): QuestStatus {\n  // If locked, stay locked - dependencies take precedence\n  if (storedStatus === \"LOCKED\") {\n    return \"LOCKED\";\n  }\n\n  // If no objectives, use stored status or default\n  if (objectives.length === 0) {\n    return storedStatus ?? defaultStatus;\n  }\n\n  const { requiredTotal, requiredCompleted } =\n    computeObjectiveProgress(objectives);\n\n  // If no required objectives, treat all objectives as required\n  const effectiveTotal = requiredTotal > 0 ? requiredTotal : objectives.length;\n  const effectiveCompleted =\n    requiredTotal > 0\n      ? requiredCompleted\n      : objectives.filter((o) => isObjectiveComplete(o.progress?.[0])).length;\n\n  // All required objectives complete -> COMPLETED\n  if (effectiveCompleted >= effectiveTotal && effectiveTotal > 0) {\n    return \"COMPLETED\";\n  }\n\n  // Some required objectives complete -> IN_PROGRESS\n  if (effectiveCompleted > 0) {\n    return \"IN_PROGRESS\";\n  }\n\n  // No objectives complete, use stored status or default\n  return storedStatus ?? defaultStatus;\n}\n\n/**\n * Check if a quest should auto-complete based on objective progress.\n * Returns true if all required objectives are marked as complete.\n * For numeric objectives, checks if current >= target.\n */\nexport function shouldAutoCompleteQuest(\n  objectives: ObjectiveWithProgress[]\n): boolean {\n  if (objectives.length === 0) {\n    return false; // Can't auto-complete a quest with no objectives\n  }\n\n  const requiredObjectives = objectives.filter((o) => !o.optional);\n\n  // If no required objectives, all objectives must be complete\n  const targetObjectives =\n    requiredObjectives.length > 0 ? requiredObjectives : objectives;\n\n  return targetObjectives.every((o) => isObjectiveComplete(o.progress?.[0]));\n}\n\n/**\n * Determine if completing/uncompleting an objective would change the quest status.\n * Useful for deciding whether to trigger auto-unlock logic.\n */\nexport function wouldObjectiveChangeQuestStatus(\n  currentStatus: QuestStatus,\n  objectives: ObjectiveWithProgress[],\n  objectiveId: string,\n  newCompletedValue: boolean,\n  newCurrent?: number | null,\n  newTarget?: number | null\n): { wouldChange: boolean; newStatus: QuestStatus } {\n  // Create a copy of objectives with the updated progress\n  const updatedObjectives = objectives.map((obj) => {\n    if (obj.id === objectiveId) {\n      return {\n        ...obj,\n        progress: [\n          {\n            completed: newCompletedValue,\n            current: newCurrent ?? null,\n            target: newTarget ?? null,\n          },\n        ],\n      };\n    }\n    return obj;\n  });\n\n  const newStatus = computeQuestStatus(currentStatus, updatedObjectives);\n  return {\n    wouldChange: newStatus !== currentStatus,\n    newStatus,\n  };\n}\n"],"names":[],"mappings":"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"}
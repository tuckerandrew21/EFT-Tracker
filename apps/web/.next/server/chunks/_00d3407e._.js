module.exports=[19502,e=>e.a(async(t,r)=>{try{var s=e.i(82570),a=e.i(14235),n=e.i(53707),i=e.i(19660),o=e.i(18387),u=e.i(57777),d=t([a,n]);[a,n]=d.then?(await d)():d;let w={LOCKED:["COMPLETED"],AVAILABLE:["IN_PROGRESS","COMPLETED"],IN_PROGRESS:["COMPLETED","AVAILABLE"],COMPLETED:["AVAILABLE"]},m=i.z.object({status:i.z.enum(["LOCKED","AVAILABLE","IN_PROGRESS","COMPLETED"])});async function l(e,{params:t}){let r=(0,u.getClientIp)(e),d=await (0,u.rateLimit)(r,u.RATE_LIMITS.API_DATA_WRITE);if(!d.success)return s.NextResponse.json({error:"Too many requests. Please try again later."},{status:429,headers:{"X-RateLimit-Limit":d.limit.toString(),"X-RateLimit-Remaining":d.remaining.toString(),"X-RateLimit-Reset":new Date(d.reset).toISOString(),"Retry-After":Math.ceil((d.reset-Date.now())/1e3).toString()}});try{let r=await (0,n.auth)();if(!r?.user?.id)return s.NextResponse.json({error:"Unauthorized"},{status:401});let{questId:i}=await t,u=await e.json(),{status:d}=m.parse(u),l=await a.prisma.questProgress.findUnique({where:{userId_questId:{userId:r.user.id,questId:i}}});if(!l){let e=await a.prisma.quest.findUnique({where:{id:i},include:{dependsOn:!0}});if(!e)return s.NextResponse.json({error:"Quest not found"},{status:404});let t="AVAILABLE";e.dependsOn.length>0&&(await c(r.user.id,e.dependsOn)||(t="LOCKED")),l=await a.prisma.questProgress.create({data:{userId:r.user.id,questId:i,status:t}})}let p=l.status,f=w[p]||[];if(!f.includes(d)&&p!==d&&("LOCKED"!==p||"AVAILABLE"!==d))return s.NextResponse.json({error:`Invalid status transition from ${p} to ${d}`,allowedTransitions:f},{status:400});let I=await a.prisma.questProgress.update({where:{userId_questId:{userId:r.user.id,questId:i}},data:{status:d}}),A=[],q=[];return"COMPLETED"===d?(await R(r.user.id,i),A=await h(r.user.id,i,"COMPLETED")):"IN_PROGRESS"===d?A=await h(r.user.id,i,"IN_PROGRESS"):"AVAILABLE"===d&&"COMPLETED"===p&&(o.logger.debug({questId:i},`Transition from COMPLETED to AVAILABLE for quest ${i}`),await E(r.user.id,i),q=await g(r.user.id,i),o.logger.debug({lockedQuests:q},"lockedQuests from autoLockDependentQuests")),s.NextResponse.json({progress:I,unlockedQuests:A,lockedQuests:q})}catch(e){if(e instanceof i.z.ZodError)return s.NextResponse.json({error:e.issues[0].message},{status:400});return o.logger.error({err:e},"Error updating progress"),s.NextResponse.json({error:"Failed to update progress"},{status:500})}}function p(e,t){if(!t)return!1;let r=t.toUpperCase();for(let t of e){let e=t.toLowerCase();if("complete"===e&&"COMPLETED"===r||"active"===e&&("IN_PROGRESS"===r||"COMPLETED"===r))return!0}return!1}async function c(e,t){if(0===t.length)return!0;let r=t.map(e=>e.requiredId),s=await a.prisma.questProgress.findMany({where:{userId:e,questId:{in:r}}}),n=new Map(s.map(e=>[e.questId,e.status]));for(let e of t){let t=n.get(e.requiredId)||null,r=e.requirementStatus||["complete"];if(!p(r,t))return!1}return!0}async function g(e,t){o.logger.debug({changedQuestId:t},`autoLockDependentQuests called for quest ${t}`);let r=await a.prisma.questDependency.findMany({where:{requiredId:t},include:{dependentQuest:{include:{dependsOn:!0}}}});o.logger.debug({count:r.length,quests:r.map(e=>e.dependentQuest.title)},`Found ${r.length} dependent quests`);let s=[];for(let t of r){let r=t.dependentQuest;o.logger.debug({questId:r.id,title:r.title},"Checking quest");let n=await c(e,r.dependsOn);if(o.logger.debug({questId:r.id,title:r.title,allDepsMet:n},"allDepsMet for quest"),!n){let t=await a.prisma.questProgress.findUnique({where:{userId_questId:{userId:e,questId:r.id}}});if(o.logger.debug({questId:r.id,title:r.title,status:t?.status},"currentProgress for quest"),t?.status==="AVAILABLE"){await a.prisma.questProgress.update({where:{userId_questId:{userId:e,questId:r.id}},data:{status:"LOCKED"}}),s.push(r.id);let t=await g(e,r.id);s.push(...t)}}}return s}async function h(e,t,r){let s=await a.prisma.questDependency.findMany({where:{requiredId:t},include:{dependentQuest:{include:{dependsOn:!0}}}}),n=[];for(let t of s){let s=t.dependentQuest,i=t.requirementStatus||["complete"];if(p(i,r)&&await c(e,s.dependsOn)){let t=await a.prisma.questProgress.findUnique({where:{userId_questId:{userId:e,questId:s.id}}});t?"LOCKED"===t.status&&(await a.prisma.questProgress.update({where:{userId_questId:{userId:e,questId:s.id}},data:{status:"AVAILABLE"}}),n.push(s.id)):(await a.prisma.questProgress.create({data:{userId:e,questId:s.id,status:"AVAILABLE"}}),n.push(s.id))}}return n}async function f(e,{params:t}){let r=(0,u.getClientIp)(e),i=await (0,u.rateLimit)(r,u.RATE_LIMITS.API_AUTHENTICATED);if(!i.success)return s.NextResponse.json({error:"Too many requests. Please try again later."},{status:429,headers:{"X-RateLimit-Limit":i.limit.toString(),"X-RateLimit-Remaining":i.remaining.toString(),"X-RateLimit-Reset":new Date(i.reset).toISOString(),"Retry-After":Math.ceil((i.reset-Date.now())/1e3).toString()}});try{let e=await (0,n.auth)();if(!e?.user?.id)return s.NextResponse.json({error:"Unauthorized"},{status:401});let{questId:r}=await t,i=await a.prisma.questProgress.findUnique({where:{userId_questId:{userId:e.user.id,questId:r}},include:{quest:{include:{trader:!0,objectives:!0}}}});if(!i)return s.NextResponse.json({error:"Progress not found"},{status:404});return s.NextResponse.json({progress:i})}catch(e){return o.logger.error({err:e},"Error fetching progress"),s.NextResponse.json({error:"Failed to fetch progress"},{status:500})}}async function R(e,t){let r=await a.prisma.objective.findMany({where:{questId:t},select:{id:!0}});for(let t of r)await a.prisma.objectiveProgress.upsert({where:{userId_objectiveId:{userId:e,objectiveId:t.id}},update:{completed:!0,syncSource:"WEB"},create:{userId:e,objectiveId:t.id,completed:!0,syncSource:"WEB"}});o.logger.debug({questId:t,objectiveCount:r.length},"Marked all objectives complete for quest")}async function E(e,t){let r=await a.prisma.objective.findMany({where:{questId:t},select:{id:!0}});await a.prisma.objectiveProgress.deleteMany({where:{userId:e,objectiveId:{in:r.map(e=>e.id)}}}),o.logger.debug({questId:t,objectiveCount:r.length},"Reset objective progress for quest")}e.s(["GET",()=>f,"PATCH",()=>l]),r()}catch(e){r(e)}},!1),79396,e=>e.a(async(t,r)=>{try{var s=e.i(21777),a=e.i(50196),n=e.i(48215),i=e.i(53098),o=e.i(56531),u=e.i(44697),d=e.i(82719),l=e.i(73958),p=e.i(54135),c=e.i(68677),g=e.i(85985),h=e.i(11293),f=e.i(36964),R=e.i(33986),E=e.i(55543),w=e.i(19386),m=e.i(93695);e.i(82304);var I=e.i(27272),A=e.i(19502),q=t([A]);[A]=q.then?(await q)():q;let L=new s.AppRouteRouteModule({definition:{kind:a.RouteKind.APP_ROUTE,page:"/api/progress/[questId]/route",pathname:"/api/progress/[questId]",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/apps/web/src/app/api/progress/[questId]/route.ts",nextConfigOutput:"standalone",userland:A}),{workAsyncStorage:P,workUnitAsyncStorage:y,serverHooks:O}=L;function v(){return(0,n.patchFetch)({workAsyncStorage:P,workUnitAsyncStorage:y})}async function C(e,t,r){L.isDev&&(0,i.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let s="/api/progress/[questId]/route";s=s.replace(/\/index$/,"")||"/";let n=await L.prepare(e,t,{srcPage:s,multiZoneDraftMode:!1});if(!n)return t.statusCode=400,t.end("Bad Request"),null==r.waitUntil||r.waitUntil.call(r,Promise.resolve()),null;let{buildId:A,params:q,nextConfig:v,parsedUrl:C,isDraftMode:P,prerenderManifest:y,routerServerContext:O,isOnDemandRevalidate:T,revalidateOnlyGenerated:S,resolvedPathname:b,clientReferenceManifest:x,serverActionsManifest:N}=n,D=(0,l.normalizeAppPath)(s),M=!!(y.dynamicRoutes[D]||y.routes[b]),_=async()=>((null==O?void 0:O.render404)?await O.render404(e,t,C,!1):t.end("This page could not be found"),null);if(M&&!P){let e=!!y.routes[b],t=y.dynamicRoutes[D];if(t&&!1===t.fallback&&!e){if(v.experimental.adapterPath)return await _();throw new m.NoFallbackError}}let j=null;!M||L.isDev||P||(j=b,j="/index"===j?"/":j);let U=!0===L.isDev||!M,H=M&&!U;N&&x&&(0,u.setReferenceManifestsSingleton)({page:s,clientReferenceManifest:x,serverActionsManifest:N,serverModuleMap:(0,d.createServerModuleMap)({serverActionsManifest:N})});let k=e.method||"GET",B=(0,o.getTracer)(),K=B.getActiveScopeSpan(),V={params:q,prerenderManifest:y,renderOpts:{experimental:{authInterrupts:!!v.experimental.authInterrupts},cacheComponents:!!v.cacheComponents,supportsDynamicResponse:U,incrementalCache:(0,i.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:v.cacheLife,waitUntil:r.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,r,s)=>L.onRequestError(e,t,s,O)},sharedContext:{buildId:A}},$=new p.NodeNextRequest(e),F=new p.NodeNextResponse(t),G=c.NextRequestAdapter.fromNodeNextRequest($,(0,c.signalFromNodeResponse)(t));try{let n=async e=>L.handle(G,V).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let r=B.getRootSpanAttributes();if(!r)return;if(r.get("next.span_type")!==g.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${r.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let a=r.get("next.route");if(a){let t=`${k} ${a}`;e.setAttributes({"next.route":a,"http.route":a,"next.span_name":t}),e.updateName(t)}else e.updateName(`${k} ${s}`)}),u=!!(0,i.getRequestMeta)(e,"minimalMode"),d=async i=>{var o,d;let l=async({previousCacheEntry:a})=>{try{if(!u&&T&&S&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let s=await n(i);e.fetchMetrics=V.renderOpts.fetchMetrics;let o=V.renderOpts.pendingWaitUntil;o&&r.waitUntil&&(r.waitUntil(o),o=void 0);let d=V.renderOpts.collectedTags;if(!M)return await (0,f.sendResponse)($,F,s,V.renderOpts.pendingWaitUntil),null;{let e=await s.blob(),t=(0,R.toNodeOutgoingHttpHeaders)(s.headers);d&&(t[w.NEXT_CACHE_TAGS_HEADER]=d),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let r=void 0!==V.renderOpts.collectedRevalidate&&!(V.renderOpts.collectedRevalidate>=w.INFINITE_CACHE)&&V.renderOpts.collectedRevalidate,a=void 0===V.renderOpts.collectedExpire||V.renderOpts.collectedExpire>=w.INFINITE_CACHE?void 0:V.renderOpts.collectedExpire;return{value:{kind:I.CachedRouteKind.APP_ROUTE,status:s.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:r,expire:a}}}}catch(t){throw(null==a?void 0:a.isStale)&&await L.onRequestError(e,t,{routerKind:"App Router",routePath:s,routeType:"route",revalidateReason:(0,h.getRevalidateReason)({isStaticGeneration:H,isOnDemandRevalidate:T})},O),t}},p=await L.handleResponse({req:e,nextConfig:v,cacheKey:j,routeKind:a.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:y,isRoutePPREnabled:!1,isOnDemandRevalidate:T,revalidateOnlyGenerated:S,responseGenerator:l,waitUntil:r.waitUntil,isMinimalMode:u});if(!M)return null;if((null==p||null==(o=p.value)?void 0:o.kind)!==I.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==p||null==(d=p.value)?void 0:d.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});u||t.setHeader("x-nextjs-cache",T?"REVALIDATED":p.isMiss?"MISS":p.isStale?"STALE":"HIT"),P&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let c=(0,R.fromNodeOutgoingHttpHeaders)(p.value.headers);return u&&M||c.delete(w.NEXT_CACHE_TAGS_HEADER),!p.cacheControl||t.getHeader("Cache-Control")||c.get("Cache-Control")||c.set("Cache-Control",(0,E.getCacheControlHeader)(p.cacheControl)),await (0,f.sendResponse)($,F,new Response(p.value.body,{headers:c,status:p.value.status||200})),null};K?await d(K):await B.withPropagatedContext(e.headers,()=>B.trace(g.BaseServerSpan.handleRequest,{spanName:`${k} ${s}`,kind:o.SpanKind.SERVER,attributes:{"http.method":k,"http.target":e.url}},d))}catch(t){if(t instanceof m.NoFallbackError||await L.onRequestError(e,t,{routerKind:"App Router",routePath:D,routeType:"route",revalidateReason:(0,h.getRevalidateReason)({isStaticGeneration:H,isOnDemandRevalidate:T})}),M)throw t;return await (0,f.sendResponse)($,F,new Response(null,{status:500})),null}}e.s(["handler",()=>C,"patchFetch",()=>v,"routeModule",()=>L,"serverHooks",()=>O,"workAsyncStorage",()=>P,"workUnitAsyncStorage",()=>y]),r()}catch(e){r(e)}},!1)];

//# sourceMappingURL=_00d3407e._.js.map
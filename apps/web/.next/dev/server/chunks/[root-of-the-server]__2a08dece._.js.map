{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 68, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tucke/Repositories/EFT-Tracker/apps/web/src/lib/env.ts"],"sourcesContent":["import { z } from \"zod\";\n\n/**\n * Environment variable validation schema\n *\n * This validates all required environment variables at application startup.\n * If any variables are missing or invalid, the application will fail to start\n * with a clear error message.\n */\nconst envSchema = z.object({\n  // Node environment\n  NODE_ENV: z\n    .enum([\"development\", \"production\", \"test\"])\n    .default(\"development\"),\n\n  // Database\n  DATABASE_URL: z\n    .string()\n    .url(\"DATABASE_URL must be a valid PostgreSQL connection string\"),\n\n  // Authentication\n  AUTH_SECRET: z\n    .string()\n    .min(\n      32,\n      \"AUTH_SECRET must be at least 32 characters. Generate with: openssl rand -base64 32\"\n    ),\n  NEXTAUTH_URL: z\n    .string()\n    .url(\"NEXTAUTH_URL must be a valid URL (e.g., https://learntotarkov.com)\"),\n\n  // Optional: GitHub integration\n  GITHUB_PERSONAL_ACCESS_TOKEN: z.string().optional(),\n\n  // Optional: Search features\n  BRAVE_API_KEY: z.string().optional(),\n\n  // Optional: Rate Limiting (Upstash Redis)\n  UPSTASH_REDIS_REST_URL: z\n    .string()\n    .url(\"UPSTASH_REDIS_REST_URL must be a valid URL\")\n    .optional(),\n  UPSTASH_REDIS_REST_TOKEN: z.string().optional(),\n\n  // Optional: Logging\n  LOG_LEVEL: z\n    .enum([\"error\", \"warn\", \"info\", \"debug\"])\n    .default(\"info\")\n    .optional(),\n\n  // Optional: Error Monitoring (Sentry)\n  SENTRY_DSN: z.string().url(\"SENTRY_DSN must be a valid URL\").optional(),\n  NEXT_PUBLIC_SENTRY_DSN: z\n    .string()\n    .url(\"NEXT_PUBLIC_SENTRY_DSN must be a valid URL\")\n    .optional(),\n  SENTRY_ORG: z.string().optional(),\n  SENTRY_PROJECT: z.string().optional(),\n  SENTRY_AUTH_TOKEN: z.string().optional(),\n});\n\n/**\n * Validated environment variables\n *\n * Import this instead of using process.env directly to ensure type safety\n * and runtime validation.\n *\n * @example\n * ```ts\n * import { env } from '@/lib/env';\n *\n * const dbUrl = env.DATABASE_URL; // Type-safe and validated\n * ```\n */\nexport const env =\n  process.env.NODE_ENV === \"test\" || process.env.SKIP_ENV_VALIDATION === \"1\"\n    ? (process.env as z.infer<typeof envSchema>)\n    : envSchema.parse(process.env);\n\nexport type Env = z.infer<typeof envSchema>;\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;;;;CAMC,GACD,MAAM,YAAY,oOAAC,CAAC,MAAM,CAAC;IACzB,mBAAmB;IACnB,UAAU,oOAAC,CACR,IAAI,CAAC;QAAC;QAAe;QAAc;KAAO,EAC1C,OAAO,CAAC;IAEX,WAAW;IACX,cAAc,oOAAC,CACZ,MAAM,GACN,GAAG,CAAC;IAEP,iBAAiB;IACjB,aAAa,oOAAC,CACX,MAAM,GACN,GAAG,CACF,IACA;IAEJ,cAAc,oOAAC,CACZ,MAAM,GACN,GAAG,CAAC;IAEP,+BAA+B;IAC/B,8BAA8B,oOAAC,CAAC,MAAM,GAAG,QAAQ;IAEjD,4BAA4B;IAC5B,eAAe,oOAAC,CAAC,MAAM,GAAG,QAAQ;IAElC,0CAA0C;IAC1C,wBAAwB,oOAAC,CACtB,MAAM,GACN,GAAG,CAAC,8CACJ,QAAQ;IACX,0BAA0B,oOAAC,CAAC,MAAM,GAAG,QAAQ;IAE7C,oBAAoB;IACpB,WAAW,oOAAC,CACT,IAAI,CAAC;QAAC;QAAS;QAAQ;QAAQ;KAAQ,EACvC,OAAO,CAAC,QACR,QAAQ;IAEX,sCAAsC;IACtC,YAAY,oOAAC,CAAC,MAAM,GAAG,GAAG,CAAC,kCAAkC,QAAQ;IACrE,wBAAwB,oOAAC,CACtB,MAAM,GACN,GAAG,CAAC,8CACJ,QAAQ;IACX,YAAY,oOAAC,CAAC,MAAM,GAAG,QAAQ;IAC/B,gBAAgB,oOAAC,CAAC,MAAM,GAAG,QAAQ;IACnC,mBAAmB,oOAAC,CAAC,MAAM,GAAG,QAAQ;AACxC;AAeO,MAAM,MACX,oDAAyB,UAAU,QAAQ,GAAG,CAAC,mBAAmB,KAAK,MAClE,QAAQ,GAAG,GACZ,UAAU,KAAK,CAAC,QAAQ,GAAG"}},
    {"offset": {"line": 120, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tucke/Repositories/EFT-Tracker/apps/web/src/lib/prisma.ts"],"sourcesContent":["import { Pool } from \"pg\";\nimport { PrismaPg } from \"@prisma/adapter-pg\";\nimport { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nfunction createPrismaClient() {\n  // Lazy import env to avoid validation errors during build time\n  // env.ts validates required env vars, which aren't available during 'next build'\n  // Using dynamic require prevents the module from being evaluated at import time\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  const { env } = require(\"./env\") as typeof import(\"./env\");\n\n  const pool = new Pool({\n    connectionString: env.DATABASE_URL,\n    // Connection pool configuration optimized for Neon Free Tier\n    // Neon Free Tier limit: 20 total connections\n    max: 10, // Maximum connections in pool (50% of Neon limit)\n    idleTimeoutMillis: 30000, // Close idle connections after 30 seconds\n    connectionTimeoutMillis: 10000, // Fail fast if connection takes >10 seconds\n  });\n  const adapter = new PrismaPg(pool);\n  return new PrismaClient({ adapter });\n}\n\n// Lazy initialization: store in global object but don't initialize until first use\nif (!globalForPrisma.prisma) {\n  globalForPrisma.prisma = undefined;\n}\n\nexport function getPrismaClient() {\n  if (!globalForPrisma.prisma) {\n    globalForPrisma.prisma = createPrismaClient();\n  }\n  return globalForPrisma.prisma;\n}\n\n// For backwards compatibility, export as a getter\nexport const prisma = new Proxy({} as PrismaClient, {\n  get(target, prop) {\n    const client = getPrismaClient();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (client as any)[prop];\n  },\n});\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;;;;;;AAEA,MAAM,kBAAkB;AAIxB,SAAS;IACP,+DAA+D;IAC/D,iFAAiF;IACjF,gFAAgF;IAChF,iEAAiE;IACjE,MAAM,EAAE,GAAG,EAAE;IAEb,MAAM,OAAO,IAAI,4GAAI,CAAC;QACpB,kBAAkB,IAAI,YAAY;QAClC,6DAA6D;QAC7D,6CAA6C;QAC7C,KAAK;QACL,mBAAmB;QACnB,yBAAyB;IAC3B;IACA,MAAM,UAAU,IAAI,+OAAQ,CAAC;IAC7B,OAAO,IAAI,6IAAY,CAAC;QAAE;IAAQ;AACpC;AAEA,mFAAmF;AACnF,IAAI,CAAC,gBAAgB,MAAM,EAAE;IAC3B,gBAAgB,MAAM,GAAG;AAC3B;AAEO,SAAS;IACd,IAAI,CAAC,gBAAgB,MAAM,EAAE;QAC3B,gBAAgB,MAAM,GAAG;IAC3B;IACA,OAAO,gBAAgB,MAAM;AAC/B;AAGO,MAAM,SAAS,IAAI,MAAM,CAAC,GAAmB;IAClD,KAAI,MAAM,EAAE,IAAI;QACd,MAAM,SAAS;QACf,8DAA8D;QAC9D,OAAO,AAAC,MAAc,CAAC,KAAK;IAC9B;AACF"}},
    {"offset": {"line": 185, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tucke/Repositories/EFT-Tracker/apps/web/src/lib/logger.ts"],"sourcesContent":["import pino from \"pino\";\nimport { env } from \"./env\";\n\n/**\n * Structured logger using Pino\n *\n * This replaces console.log/error/warn throughout the application with\n * structured JSON logging for better production observability.\n *\n * Features:\n * - Automatic PII redaction (passwords, tokens, emails)\n * - Pretty-printed output in development\n * - JSON output in production for log aggregation\n * - Configurable log levels via LOG_LEVEL env var\n *\n * @example\n * ```ts\n * import { logger } from '@/lib/logger';\n *\n * logger.info({ userId }, 'User registered successfully');\n * logger.error({ err: error }, 'Database query failed');\n * logger.warn({ duration: 1500 }, 'Slow query detected');\n * ```\n */\n\n// Get log level from environment, default to 'info'\nconst logLevel =\n  process.env.LOG_LEVEL || (env.NODE_ENV === \"production\" ? \"info\" : \"debug\");\n\nexport const logger = pino({\n  level: logLevel,\n\n  // Redact sensitive fields from logs\n  redact: {\n    paths: [\n      \"password\",\n      \"token\",\n      \"email\",\n      \"companionToken\",\n      \"apiToken\",\n      \"AUTH_SECRET\",\n      \"DATABASE_URL\",\n      \"*.password\",\n      \"*.token\",\n      \"*.companionToken\",\n      \"req.headers.authorization\",\n      \"req.headers.cookie\",\n    ],\n    censor: \"[REDACTED]\",\n  },\n\n  // Format log level as a string (not a number)\n  formatters: {\n    level: (label) => ({ level: label }),\n  },\n\n  // Use pino-pretty for readable logs in development\n  ...(env.NODE_ENV === \"development\" && {\n    transport: {\n      target: \"pino-pretty\",\n      options: {\n        colorize: true,\n        translateTime: \"HH:MM:ss\",\n        ignore: \"pid,hostname\",\n      },\n    },\n  }),\n});\n\n/**\n * Create a child logger with additional context\n *\n * @example\n * ```ts\n * const reqLogger = logger.child({ requestId: req.id });\n * reqLogger.info('Processing request');\n * ```\n */\nexport function createRequestLogger(requestId: string, userId?: string) {\n  return logger.child({\n    requestId,\n    ...(userId && { userId }),\n  });\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA;;;;;;;;;;;;;;;;;;;;CAoBC,GAED,oDAAoD;AACpD,MAAM,WACJ,QAAQ,GAAG,CAAC,SAAS,IAAI,CAAC,yIAAG,CAAC,QAAQ,KAAK,eAAe,SAAS,OAAO;AAErE,MAAM,SAAS,IAAA,4GAAI,EAAC;IACzB,OAAO;IAEP,oCAAoC;IACpC,QAAQ;QACN,OAAO;YACL;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;SACD;QACD,QAAQ;IACV;IAEA,8CAA8C;IAC9C,YAAY;QACV,OAAO,CAAC,QAAU,CAAC;gBAAE,OAAO;YAAM,CAAC;IACrC;IAEA,mDAAmD;IACnD,GAAI,yIAAG,CAAC,QAAQ,KAAK,iBAAiB;QACpC,WAAW;YACT,QAAQ;YACR,SAAS;gBACP,UAAU;gBACV,eAAe;gBACf,QAAQ;YACV;QACF;IACF,CAAC;AACH;AAWO,SAAS,oBAAoB,SAAiB,EAAE,MAAe;IACpE,OAAO,OAAO,KAAK,CAAC;QAClB;QACA,GAAI,UAAU;YAAE;QAAO,CAAC;IAC1B;AACF"}},
    {"offset": {"line": 269, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tucke/Repositories/EFT-Tracker/apps/web/src/lib/security-logger.ts"],"sourcesContent":["import { prisma } from \"./prisma\";\nimport { logger } from \"./logger\";\nimport crypto from \"crypto\";\nimport type { SecurityEventType } from \"@prisma/client\";\n\ninterface SecurityEventData {\n  type: SecurityEventType;\n  userId?: string;\n  email?: string;\n  ipAddress: string;\n  userAgent?: string;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Log a security event to the database\n * Automatically hashes email addresses for privacy\n * Triggers alerts for suspicious activity\n */\nexport async function logSecurityEvent(data: SecurityEventData) {\n  try {\n    // Hash email for privacy (can still correlate events without storing PII)\n    const emailHash = data.email\n      ? crypto.createHash(\"sha256\").update(data.email).digest(\"hex\")\n      : undefined;\n\n    await prisma.securityEvent.create({\n      data: {\n        type: data.type,\n        userId: data.userId,\n        ipAddress: data.ipAddress,\n        userAgent: data.userAgent,\n        metadata: {\n          ...data.metadata,\n          emailHash,\n        },\n      },\n    });\n\n    // Check for suspicious activity patterns\n    if (data.type === \"LOGIN_FAILED\") {\n      await checkFailedLoginThreshold(data.ipAddress);\n    }\n\n    if (data.type === \"RATE_LIMIT_EXCEEDED\") {\n      await checkRateLimitPattern(data.ipAddress);\n    }\n  } catch (error) {\n    // Don't fail the request if logging fails\n    logger.error(\n      { error, eventType: data.type },\n      \"Failed to log security event\"\n    );\n  }\n}\n\n/**\n * Check if an IP has exceeded the failed login threshold\n * Alert if >10 failed logins in the last hour\n */\nasync function checkFailedLoginThreshold(ipAddress: string) {\n  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n\n  const failedAttempts = await prisma.securityEvent.count({\n    where: {\n      type: \"LOGIN_FAILED\",\n      ipAddress,\n      createdAt: { gte: oneHourAgo },\n    },\n  });\n\n  if (failedAttempts >= 10) {\n    logger.warn(\n      { ipAddress, failedAttempts },\n      \"Suspicious login activity detected - possible brute force attack\"\n    );\n  }\n}\n\n/**\n * Check if an IP is repeatedly hitting rate limits\n * Alert if >5 rate limit violations in 15 minutes\n */\nasync function checkRateLimitPattern(ipAddress: string) {\n  const fifteenMinutesAgo = new Date(Date.now() - 15 * 60 * 1000);\n\n  const rateLimitHits = await prisma.securityEvent.count({\n    where: {\n      type: \"RATE_LIMIT_EXCEEDED\",\n      ipAddress,\n      createdAt: { gte: fifteenMinutesAgo },\n    },\n  });\n\n  if (rateLimitHits >= 5) {\n    logger.warn(\n      { ipAddress, rateLimitHits },\n      \"Repeated rate limit violations - possible automated attack\"\n    );\n  }\n}\n\n/**\n * Get security events for a user (for security dashboard)\n */\nexport async function getUserSecurityEvents(userId: string, limit = 50) {\n  return prisma.securityEvent.findMany({\n    where: { userId },\n    orderBy: { createdAt: \"desc\" },\n    take: limit,\n  });\n}\n\n/**\n * Get security events for an IP address (for investigation)\n */\nexport async function getIpSecurityEvents(ipAddress: string, limit = 50) {\n  return prisma.securityEvent.findMany({\n    where: { ipAddress },\n    orderBy: { createdAt: \"desc\" },\n    take: limit,\n  });\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;;;;;AAiBO,eAAe,iBAAiB,IAAuB;IAC5D,IAAI;QACF,0EAA0E;QAC1E,MAAM,YAAY,KAAK,KAAK,GACxB,gHAAM,CAAC,UAAU,CAAC,UAAU,MAAM,CAAC,KAAK,KAAK,EAAE,MAAM,CAAC,SACtD;QAEJ,MAAM,+IAAM,CAAC,aAAa,CAAC,MAAM,CAAC;YAChC,MAAM;gBACJ,MAAM,KAAK,IAAI;gBACf,QAAQ,KAAK,MAAM;gBACnB,WAAW,KAAK,SAAS;gBACzB,WAAW,KAAK,SAAS;gBACzB,UAAU;oBACR,GAAG,KAAK,QAAQ;oBAChB;gBACF;YACF;QACF;QAEA,yCAAyC;QACzC,IAAI,KAAK,IAAI,KAAK,gBAAgB;YAChC,MAAM,0BAA0B,KAAK,SAAS;QAChD;QAEA,IAAI,KAAK,IAAI,KAAK,uBAAuB;YACvC,MAAM,sBAAsB,KAAK,SAAS;QAC5C;IACF,EAAE,OAAO,OAAO;QACd,0CAA0C;QAC1C,+IAAM,CAAC,KAAK,CACV;YAAE;YAAO,WAAW,KAAK,IAAI;QAAC,GAC9B;IAEJ;AACF;AAEA;;;CAGC,GACD,eAAe,0BAA0B,SAAiB;IACxD,MAAM,aAAa,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK;IAEnD,MAAM,iBAAiB,MAAM,+IAAM,CAAC,aAAa,CAAC,KAAK,CAAC;QACtD,OAAO;YACL,MAAM;YACN;YACA,WAAW;gBAAE,KAAK;YAAW;QAC/B;IACF;IAEA,IAAI,kBAAkB,IAAI;QACxB,+IAAM,CAAC,IAAI,CACT;YAAE;YAAW;QAAe,GAC5B;IAEJ;AACF;AAEA;;;CAGC,GACD,eAAe,sBAAsB,SAAiB;IACpD,MAAM,oBAAoB,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK;IAE1D,MAAM,gBAAgB,MAAM,+IAAM,CAAC,aAAa,CAAC,KAAK,CAAC;QACrD,OAAO;YACL,MAAM;YACN;YACA,WAAW;gBAAE,KAAK;YAAkB;QACtC;IACF;IAEA,IAAI,iBAAiB,GAAG;QACtB,+IAAM,CAAC,IAAI,CACT;YAAE;YAAW;QAAc,GAC3B;IAEJ;AACF;AAKO,eAAe,sBAAsB,MAAc,EAAE,QAAQ,EAAE;IACpE,OAAO,+IAAM,CAAC,aAAa,CAAC,QAAQ,CAAC;QACnC,OAAO;YAAE;QAAO;QAChB,SAAS;YAAE,WAAW;QAAO;QAC7B,MAAM;IACR;AACF;AAKO,eAAe,oBAAoB,SAAiB,EAAE,QAAQ,EAAE;IACrE,OAAO,+IAAM,CAAC,aAAa,CAAC,QAAQ,CAAC;QACnC,OAAO;YAAE;QAAU;QACnB,SAAS;YAAE,WAAW;QAAO;QAC7B,MAAM;IACR;AACF"}},
    {"offset": {"line": 389, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tucke/Repositories/EFT-Tracker/apps/web/src/lib/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\";\nimport Credentials from \"next-auth/providers/credentials\";\nimport bcrypt from \"bcryptjs\";\nimport { prisma } from \"./prisma\";\nimport { logSecurityEvent } from \"./security-logger\";\n\nexport const { handlers, signIn, signOut, auth } = NextAuth({\n  trustHost: true,\n  providers: [\n    Credentials({\n      name: \"credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" },\n      },\n      async authorize(credentials, request) {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n\n        const email = credentials.email as string;\n        const password = credentials.password as string;\n\n        // Get IP and user agent from request\n        const ipAddress =\n          request?.headers?.get(\"x-forwarded-for\") ||\n          request?.headers?.get(\"x-real-ip\") ||\n          \"unknown\";\n        const userAgent = request?.headers?.get(\"user-agent\") ?? undefined;\n\n        const user = await prisma.user.findUnique({\n          where: { email },\n        });\n\n        if (!user) {\n          // Log failed login - user not found\n          await logSecurityEvent({\n            type: \"LOGIN_FAILED\",\n            email,\n            ipAddress,\n            userAgent,\n            metadata: { reason: \"user_not_found\" },\n          });\n          return null;\n        }\n\n        const passwordMatch = await bcrypt.compare(password, user.password);\n\n        if (!passwordMatch) {\n          // Log failed login - invalid password\n          await logSecurityEvent({\n            type: \"LOGIN_FAILED\",\n            userId: user.id,\n            email,\n            ipAddress,\n            userAgent,\n            metadata: { reason: \"invalid_password\" },\n          });\n          return null;\n        }\n\n        // Log successful login\n        await logSecurityEvent({\n          type: \"LOGIN_SUCCESS\",\n          userId: user.id,\n          email,\n          ipAddress,\n          userAgent,\n        });\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n        };\n      },\n    }),\n  ],\n  session: {\n    strategy: \"jwt\",\n  },\n  pages: {\n    signIn: \"/login\",\n  },\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (session.user) {\n        session.user.id = token.id as string;\n      }\n      return session;\n    },\n  },\n});\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;AAEO,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,IAAA,8QAAQ,EAAC;IAC1D,WAAW;IACX,WAAW;QACT,IAAA,mOAAW,EAAC;YACV,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW,EAAE,OAAO;gBAClC,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,OAAO;gBACT;gBAEA,MAAM,QAAQ,YAAY,KAAK;gBAC/B,MAAM,WAAW,YAAY,QAAQ;gBAErC,qCAAqC;gBACrC,MAAM,YACJ,SAAS,SAAS,IAAI,sBACtB,SAAS,SAAS,IAAI,gBACtB;gBACF,MAAM,YAAY,SAAS,SAAS,IAAI,iBAAiB;gBAEzD,MAAM,OAAO,MAAM,+IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBAAE;oBAAM;gBACjB;gBAEA,IAAI,CAAC,MAAM;oBACT,oCAAoC;oBACpC,MAAM,IAAA,qKAAgB,EAAC;wBACrB,MAAM;wBACN;wBACA;wBACA;wBACA,UAAU;4BAAE,QAAQ;wBAAiB;oBACvC;oBACA,OAAO;gBACT;gBAEA,MAAM,gBAAgB,MAAM,mMAAM,CAAC,OAAO,CAAC,UAAU,KAAK,QAAQ;gBAElE,IAAI,CAAC,eAAe;oBAClB,sCAAsC;oBACtC,MAAM,IAAA,qKAAgB,EAAC;wBACrB,MAAM;wBACN,QAAQ,KAAK,EAAE;wBACf;wBACA;wBACA;wBACA,UAAU;4BAAE,QAAQ;wBAAmB;oBACzC;oBACA,OAAO;gBACT;gBAEA,uBAAuB;gBACvB,MAAM,IAAA,qKAAgB,EAAC;oBACrB,MAAM;oBACN,QAAQ,KAAK,EAAE;oBACf;oBACA;oBACA;gBACF;gBAEA,OAAO;oBACL,IAAI,KAAK,EAAE;oBACX,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;gBACjB;YACF;QACF;KACD;IACD,SAAS;QACP,UAAU;IACZ;IACA,OAAO;QACL,QAAQ;IACV;IACA,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;YACpB;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;YAC5B;YACA,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 520, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tucke/Repositories/EFT-Tracker/apps/web/src/lib/rate-limit.ts"],"sourcesContent":["/**\n * Rate limiting utility with Upstash Redis backend\n *\n * Uses Upstash Redis for distributed rate limiting across multiple server instances.\n * Falls back to in-memory rate limiting if Upstash credentials are not configured.\n *\n * For production deployments with multiple instances, configure Upstash Redis:\n * - UPSTASH_REDIS_REST_URL\n * - UPSTASH_REDIS_REST_TOKEN\n */\n\nimport { Ratelimit } from \"@upstash/ratelimit\";\nimport { Redis } from \"@upstash/redis\";\nimport { env } from \"./env\";\nimport { logger } from \"./logger\";\n\nexport interface RateLimitConfig {\n  /**\n   * Maximum number of requests allowed within the window\n   */\n  limit: number;\n  /**\n   * Time window in milliseconds\n   */\n  window: number;\n}\n\nexport interface RateLimitResult {\n  success: boolean;\n  limit: number;\n  remaining: number;\n  reset: number;\n}\n\n// ============================================================================\n// Upstash Redis Rate Limiter (Distributed)\n// ============================================================================\n\nlet upstashRateLimiter: Ratelimit | null = null;\n\nfunction getUpstashRateLimiter(config: RateLimitConfig): Ratelimit | null {\n  // Return existing instance if config matches\n  if (upstashRateLimiter) {\n    return upstashRateLimiter;\n  }\n\n  // Check if Upstash credentials are configured\n  if (!env.UPSTASH_REDIS_REST_URL || !env.UPSTASH_REDIS_REST_TOKEN) {\n    return null;\n  }\n\n  try {\n    const redis = new Redis({\n      url: env.UPSTASH_REDIS_REST_URL,\n      token: env.UPSTASH_REDIS_REST_TOKEN,\n    });\n\n    upstashRateLimiter = new Ratelimit({\n      redis,\n      limiter: Ratelimit.slidingWindow(config.limit, `${config.window}ms`),\n      analytics: false,\n      prefix: \"eft-tracker:ratelimit\",\n    });\n\n    logger.info(\n      {\n        url: env.UPSTASH_REDIS_REST_URL,\n        limit: config.limit,\n        window: config.window,\n      },\n      \"Upstash rate limiter initialized\"\n    );\n\n    return upstashRateLimiter;\n  } catch (error) {\n    logger.error(\n      {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      },\n      \"Failed to initialize Upstash rate limiter, falling back to in-memory\"\n    );\n    return null;\n  }\n}\n\nasync function rateLimitWithUpstash(\n  identifier: string,\n  config: RateLimitConfig\n): Promise<RateLimitResult> {\n  const limiter = getUpstashRateLimiter(config);\n\n  if (!limiter) {\n    // Fallback to in-memory\n    return rateLimitInMemory(identifier, config);\n  }\n\n  try {\n    const result = await limiter.limit(identifier);\n\n    return {\n      success: result.success,\n      limit: result.limit,\n      remaining: result.remaining,\n      reset: result.reset,\n    };\n  } catch (error) {\n    logger.error(\n      {\n        error: error instanceof Error ? error.message : \"Unknown error\",\n        identifier,\n      },\n      \"Upstash rate limit check failed, falling back to in-memory\"\n    );\n\n    // Fallback to in-memory on error\n    return rateLimitInMemory(identifier, config);\n  }\n}\n\n// ============================================================================\n// In-Memory Rate Limiter (Fallback)\n// ============================================================================\n\ninterface RateLimitEntry {\n  count: number;\n  resetAt: number;\n}\n\nconst rateLimitStore = new Map<string, RateLimitEntry>();\n\n// Cleanup old entries every 5 minutes\nsetInterval(\n  () => {\n    const now = Date.now();\n    for (const [key, entry] of rateLimitStore.entries()) {\n      if (entry.resetAt < now) {\n        rateLimitStore.delete(key);\n      }\n    }\n  },\n  5 * 60 * 1000\n);\n\nfunction rateLimitInMemory(\n  identifier: string,\n  config: RateLimitConfig\n): RateLimitResult {\n  const now = Date.now();\n  const key = identifier;\n\n  let entry = rateLimitStore.get(key);\n\n  // Initialize or reset if window expired\n  if (!entry || entry.resetAt < now) {\n    entry = {\n      count: 0,\n      resetAt: now + config.window,\n    };\n    rateLimitStore.set(key, entry);\n  }\n\n  // Increment count\n  entry.count++;\n\n  const remaining = Math.max(0, config.limit - entry.count);\n  const success = entry.count <= config.limit;\n\n  return {\n    success,\n    limit: config.limit,\n    remaining,\n    reset: entry.resetAt,\n  };\n}\n\n// ============================================================================\n// Public API\n// ============================================================================\n\n/**\n * Check if a request should be rate limited\n *\n * Uses Upstash Redis for distributed rate limiting if configured,\n * otherwise falls back to in-memory rate limiting.\n *\n * @param identifier - Unique identifier for the rate limit (e.g., IP address, user ID)\n * @param config - Rate limit configuration\n * @returns Rate limit result with success status and metadata\n */\nexport async function rateLimit(\n  identifier: string,\n  config: RateLimitConfig\n): Promise<RateLimitResult> {\n  return rateLimitWithUpstash(identifier, config);\n}\n\n/**\n * Get client IP address from request headers\n * Handles various proxy headers in correct priority order\n */\nexport function getClientIp(request: Request): string {\n  // Cloudflare (highest priority - most trustworthy)\n  const cfConnectingIp = request.headers.get(\"cf-connecting-ip\");\n  if (cfConnectingIp) {\n    return cfConnectingIp.trim();\n  }\n\n  // Standard forwarded header\n  const forwarded = request.headers.get(\"x-forwarded-for\");\n  if (forwarded) {\n    // x-forwarded-for can be a comma-separated list, take the first (original client)\n    return forwarded.split(\",\")[0].trim();\n  }\n\n  // Real IP header (used by some proxies)\n  const realIp = request.headers.get(\"x-real-ip\");\n  if (realIp) {\n    return realIp.trim();\n  }\n\n  // Fallback to 'unknown' if no IP found\n  return \"unknown\";\n}\n\n/**\n * Predefined rate limit configurations\n */\nexport const RATE_LIMITS = {\n  /**\n   * 5 attempts per 15 minutes for login\n   */\n  AUTH_LOGIN: {\n    limit: 5,\n    window: 15 * 60 * 1000, // 15 minutes\n  },\n  /**\n   * 3 attempts per hour for registration\n   */\n  AUTH_REGISTER: {\n    limit: 3,\n    window: 60 * 60 * 1000, // 1 hour\n  },\n  /**\n   * 30 requests per minute for general API routes\n   */\n  API_GENERAL: {\n    limit: 30,\n    window: 60 * 1000, // 1 minute\n  },\n  /**\n   * 60 requests per minute for data read operations (GET)\n   */\n  API_DATA_READ: {\n    limit: 60,\n    window: 60 * 1000, // 1 minute\n  },\n  /**\n   * 50 requests per minute for data write operations (POST/PUT/DELETE)\n   */\n  API_DATA_WRITE: {\n    limit: 50,\n    window: 60 * 1000, // 1 minute\n  },\n  /**\n   * 100 requests per minute for authenticated users\n   */\n  API_AUTHENTICATED: {\n    limit: 100,\n    window: 60 * 1000, // 1 minute\n  },\n  /**\n   * 20 requests per minute for search operations\n   */\n  API_SEARCH: {\n    limit: 20,\n    window: 60 * 1000, // 1 minute\n  },\n  /**\n   * 30 requests per minute for companion app API\n   */\n  API_COMPANION: {\n    limit: 30,\n    window: 60 * 1000, // 1 minute\n  },\n} as const;\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 717, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tucke/Repositories/EFT-Tracker/apps/web/src/app/api/auth/%5B...nextauth%5D/route.ts"],"sourcesContent":["import { handlers } from \"@/lib/auth\";\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { rateLimit, getClientIp, RATE_LIMITS } from \"@/lib/rate-limit\";\nimport { logSecurityEvent } from \"@/lib/security-logger\";\n\n// Wrap POST handler with rate limiting for login attempts\nconst originalPOST = handlers.POST;\n\nasync function POST(request: NextRequest) {\n  // Only apply rate limiting to login attempts (credentials provider)\n  // Check if this is a credentials signin request\n  const url = new URL(request.url);\n  const isCredentialsLogin =\n    url.pathname.includes(\"/callback/credentials\") ||\n    url.searchParams.get(\"provider\") === \"credentials\";\n\n  if (isCredentialsLogin) {\n    const clientIp = getClientIp(request);\n    const rateLimitResult = await rateLimit(clientIp, RATE_LIMITS.AUTH_LOGIN);\n\n    if (!rateLimitResult.success) {\n      // Log rate limit exceeded\n      await logSecurityEvent({\n        type: \"RATE_LIMIT_EXCEEDED\",\n        ipAddress: clientIp,\n        userAgent: request.headers.get(\"user-agent\") ?? undefined,\n        metadata: { endpoint: \"/api/auth/[...nextauth]\" },\n      });\n\n      return NextResponse.json(\n        { error: \"Too many login attempts. Please try again later.\" },\n        {\n          status: 429,\n          headers: {\n            \"X-RateLimit-Limit\": rateLimitResult.limit.toString(),\n            \"X-RateLimit-Remaining\": rateLimitResult.remaining.toString(),\n            \"X-RateLimit-Reset\": new Date(rateLimitResult.reset).toISOString(),\n            \"Retry-After\": Math.ceil(\n              (rateLimitResult.reset - Date.now()) / 1000\n            ).toString(),\n          },\n        }\n      );\n    }\n  }\n\n  return originalPOST(request);\n}\n\nexport const GET = handlers.GET;\nexport { POST };\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;AACA;;;;;;;;;;AAEA,0DAA0D;AAC1D,MAAM,eAAe,+IAAQ,CAAC,IAAI;AAElC,eAAe,KAAK,OAAoB;IACtC,oEAAoE;IACpE,gDAAgD;IAChD,MAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;IAC/B,MAAM,qBACJ,IAAI,QAAQ,CAAC,QAAQ,CAAC,4BACtB,IAAI,YAAY,CAAC,GAAG,CAAC,gBAAgB;IAEvC,IAAI,oBAAoB;QACtB,MAAM,WAAW,IAAA,2JAAW,EAAC;QAC7B,MAAM,kBAAkB,MAAM,IAAA,yJAAS,EAAC,UAAU,2JAAW,CAAC,UAAU;QAExE,IAAI,CAAC,gBAAgB,OAAO,EAAE;YAC5B,0BAA0B;YAC1B,MAAM,IAAA,qKAAgB,EAAC;gBACrB,MAAM;gBACN,WAAW;gBACX,WAAW,QAAQ,OAAO,CAAC,GAAG,CAAC,iBAAiB;gBAChD,UAAU;oBAAE,UAAU;gBAA0B;YAClD;YAEA,OAAO,+PAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAmD,GAC5D;gBACE,QAAQ;gBACR,SAAS;oBACP,qBAAqB,gBAAgB,KAAK,CAAC,QAAQ;oBACnD,yBAAyB,gBAAgB,SAAS,CAAC,QAAQ;oBAC3D,qBAAqB,IAAI,KAAK,gBAAgB,KAAK,EAAE,WAAW;oBAChE,eAAe,KAAK,IAAI,CACtB,CAAC,gBAAgB,KAAK,GAAG,KAAK,GAAG,EAAE,IAAI,MACvC,QAAQ;gBACZ;YACF;QAEJ;IACF;IAEA,OAAO,aAAa;AACtB;AAEO,MAAM,MAAM,+IAAQ,CAAC,GAAG"}}]
}
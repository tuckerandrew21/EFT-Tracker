{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 56, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tucke/Repositories/EFT-Tracker/apps/web/src/lib/env.ts"],"sourcesContent":["import { z } from \"zod\";\n\n/**\n * Environment variable validation schema\n *\n * This validates all required environment variables at application startup.\n * If any variables are missing or invalid, the application will fail to start\n * with a clear error message.\n */\nconst envSchema = z.object({\n  // Node environment\n  NODE_ENV: z\n    .enum([\"development\", \"production\", \"test\"])\n    .default(\"development\"),\n\n  // Database\n  DATABASE_URL: z\n    .string()\n    .url(\"DATABASE_URL must be a valid PostgreSQL connection string\"),\n\n  // Authentication\n  AUTH_SECRET: z\n    .string()\n    .min(\n      32,\n      \"AUTH_SECRET must be at least 32 characters. Generate with: openssl rand -base64 32\"\n    ),\n  NEXTAUTH_URL: z\n    .string()\n    .url(\"NEXTAUTH_URL must be a valid URL (e.g., https://learntotarkov.com)\"),\n\n  // Optional: GitHub integration\n  GITHUB_PERSONAL_ACCESS_TOKEN: z.string().optional(),\n\n  // Optional: Search features\n  BRAVE_API_KEY: z.string().optional(),\n\n  // Optional: Rate Limiting (Upstash Redis)\n  UPSTASH_REDIS_REST_URL: z\n    .string()\n    .url(\"UPSTASH_REDIS_REST_URL must be a valid URL\")\n    .optional(),\n  UPSTASH_REDIS_REST_TOKEN: z.string().optional(),\n\n  // Optional: Logging\n  LOG_LEVEL: z\n    .enum([\"error\", \"warn\", \"info\", \"debug\"])\n    .default(\"info\")\n    .optional(),\n\n  // Optional: Error Monitoring (Sentry)\n  SENTRY_DSN: z.string().url(\"SENTRY_DSN must be a valid URL\").optional(),\n  NEXT_PUBLIC_SENTRY_DSN: z\n    .string()\n    .url(\"NEXT_PUBLIC_SENTRY_DSN must be a valid URL\")\n    .optional(),\n  SENTRY_ORG: z.string().optional(),\n  SENTRY_PROJECT: z.string().optional(),\n  SENTRY_AUTH_TOKEN: z.string().optional(),\n});\n\n/**\n * Validated environment variables\n *\n * Import this instead of using process.env directly to ensure type safety\n * and runtime validation.\n *\n * @example\n * ```ts\n * import { env } from '@/lib/env';\n *\n * const dbUrl = env.DATABASE_URL; // Type-safe and validated\n * ```\n */\nexport const env =\n  process.env.NODE_ENV === \"test\" || process.env.SKIP_ENV_VALIDATION === \"1\"\n    ? (process.env as z.infer<typeof envSchema>)\n    : envSchema.parse(process.env);\n\nexport type Env = z.infer<typeof envSchema>;\n"],"names":[],"mappings":";;;;AAAA;;AAEA;;;;;;CAMC,GACD,MAAM,YAAY,oOAAC,CAAC,MAAM,CAAC;IACzB,mBAAmB;IACnB,UAAU,oOAAC,CACR,IAAI,CAAC;QAAC;QAAe;QAAc;KAAO,EAC1C,OAAO,CAAC;IAEX,WAAW;IACX,cAAc,oOAAC,CACZ,MAAM,GACN,GAAG,CAAC;IAEP,iBAAiB;IACjB,aAAa,oOAAC,CACX,MAAM,GACN,GAAG,CACF,IACA;IAEJ,cAAc,oOAAC,CACZ,MAAM,GACN,GAAG,CAAC;IAEP,+BAA+B;IAC/B,8BAA8B,oOAAC,CAAC,MAAM,GAAG,QAAQ;IAEjD,4BAA4B;IAC5B,eAAe,oOAAC,CAAC,MAAM,GAAG,QAAQ;IAElC,0CAA0C;IAC1C,wBAAwB,oOAAC,CACtB,MAAM,GACN,GAAG,CAAC,8CACJ,QAAQ;IACX,0BAA0B,oOAAC,CAAC,MAAM,GAAG,QAAQ;IAE7C,oBAAoB;IACpB,WAAW,oOAAC,CACT,IAAI,CAAC;QAAC;QAAS;QAAQ;QAAQ;KAAQ,EACvC,OAAO,CAAC,QACR,QAAQ;IAEX,sCAAsC;IACtC,YAAY,oOAAC,CAAC,MAAM,GAAG,GAAG,CAAC,kCAAkC,QAAQ;IACrE,wBAAwB,oOAAC,CACtB,MAAM,GACN,GAAG,CAAC,8CACJ,QAAQ;IACX,YAAY,oOAAC,CAAC,MAAM,GAAG,QAAQ;IAC/B,gBAAgB,oOAAC,CAAC,MAAM,GAAG,QAAQ;IACnC,mBAAmB,oOAAC,CAAC,MAAM,GAAG,QAAQ;AACxC;AAeO,MAAM,MACX,oDAAyB,UAAU,QAAQ,GAAG,CAAC,mBAAmB,KAAK,MAClE,QAAQ,GAAG,GACZ,UAAU,KAAK,CAAC,QAAQ,GAAG"}},
    {"offset": {"line": 108, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tucke/Repositories/EFT-Tracker/apps/web/src/lib/prisma.ts"],"sourcesContent":["import { Pool } from \"pg\";\nimport { PrismaPg } from \"@prisma/adapter-pg\";\nimport { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nfunction createPrismaClient() {\n  // Lazy import env to avoid validation errors during build time\n  // env.ts validates required env vars, which aren't available during 'next build'\n  // Using dynamic require prevents the module from being evaluated at import time\n  // eslint-disable-next-line @typescript-eslint/no-require-imports\n  const { env } = require(\"./env\") as typeof import(\"./env\");\n\n  const pool = new Pool({\n    connectionString: env.DATABASE_URL,\n    // Connection pool configuration optimized for Neon Free Tier\n    // Neon Free Tier limit: 20 total connections\n    max: 10, // Maximum connections in pool (50% of Neon limit)\n    idleTimeoutMillis: 30000, // Close idle connections after 30 seconds\n    connectionTimeoutMillis: 10000, // Fail fast if connection takes >10 seconds\n  });\n  const adapter = new PrismaPg(pool);\n  return new PrismaClient({ adapter });\n}\n\n// Lazy initialization: store in global object but don't initialize until first use\nif (!globalForPrisma.prisma) {\n  globalForPrisma.prisma = undefined;\n}\n\nexport function getPrismaClient() {\n  if (!globalForPrisma.prisma) {\n    globalForPrisma.prisma = createPrismaClient();\n  }\n  return globalForPrisma.prisma;\n}\n\n// For backwards compatibility, export as a getter\nexport const prisma = new Proxy({} as PrismaClient, {\n  get(target, prop) {\n    const client = getPrismaClient();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (client as any)[prop];\n  },\n});\n"],"names":[],"mappings":";;;;;;AAAA;AACA;AACA;;;;;;;;;AAEA,MAAM,kBAAkB;AAIxB,SAAS;IACP,+DAA+D;IAC/D,iFAAiF;IACjF,gFAAgF;IAChF,iEAAiE;IACjE,MAAM,EAAE,GAAG,EAAE;IAEb,MAAM,OAAO,IAAI,4GAAI,CAAC;QACpB,kBAAkB,IAAI,YAAY;QAClC,6DAA6D;QAC7D,6CAA6C;QAC7C,KAAK;QACL,mBAAmB;QACnB,yBAAyB;IAC3B;IACA,MAAM,UAAU,IAAI,+OAAQ,CAAC;IAC7B,OAAO,IAAI,6IAAY,CAAC;QAAE;IAAQ;AACpC;AAEA,mFAAmF;AACnF,IAAI,CAAC,gBAAgB,MAAM,EAAE;IAC3B,gBAAgB,MAAM,GAAG;AAC3B;AAEO,SAAS;IACd,IAAI,CAAC,gBAAgB,MAAM,EAAE;QAC3B,gBAAgB,MAAM,GAAG;IAC3B;IACA,OAAO,gBAAgB,MAAM;AAC/B;AAGO,MAAM,SAAS,IAAI,MAAM,CAAC,GAAmB;IAClD,KAAI,MAAM,EAAE,IAAI;QACd,MAAM,SAAS;QACf,8DAA8D;QAC9D,OAAO,AAAC,MAAc,CAAC,KAAK;IAC9B;AACF"}},
    {"offset": {"line": 185, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tucke/Repositories/EFT-Tracker/apps/web/src/lib/logger.ts"],"sourcesContent":["import pino from \"pino\";\nimport { env } from \"./env\";\n\n/**\n * Structured logger using Pino\n *\n * This replaces console.log/error/warn throughout the application with\n * structured JSON logging for better production observability.\n *\n * Features:\n * - Automatic PII redaction (passwords, tokens, emails)\n * - Pretty-printed output in development\n * - JSON output in production for log aggregation\n * - Configurable log levels via LOG_LEVEL env var\n *\n * @example\n * ```ts\n * import { logger } from '@/lib/logger';\n *\n * logger.info({ userId }, 'User registered successfully');\n * logger.error({ err: error }, 'Database query failed');\n * logger.warn({ duration: 1500 }, 'Slow query detected');\n * ```\n */\n\n// Get log level from environment, default to 'info'\nconst logLevel =\n  process.env.LOG_LEVEL || (env.NODE_ENV === \"production\" ? \"info\" : \"debug\");\n\nexport const logger = pino({\n  level: logLevel,\n\n  // Redact sensitive fields from logs\n  redact: {\n    paths: [\n      \"password\",\n      \"token\",\n      \"email\",\n      \"companionToken\",\n      \"apiToken\",\n      \"AUTH_SECRET\",\n      \"DATABASE_URL\",\n      \"*.password\",\n      \"*.token\",\n      \"*.companionToken\",\n      \"req.headers.authorization\",\n      \"req.headers.cookie\",\n    ],\n    censor: \"[REDACTED]\",\n  },\n\n  // Format log level as a string (not a number)\n  formatters: {\n    level: (label) => ({ level: label }),\n  },\n\n  // Use pino-pretty for readable logs in development\n  ...(env.NODE_ENV === \"development\" && {\n    transport: {\n      target: \"pino-pretty\",\n      options: {\n        colorize: true,\n        translateTime: \"HH:MM:ss\",\n        ignore: \"pid,hostname\",\n      },\n    },\n  }),\n});\n\n/**\n * Create a child logger with additional context\n *\n * @example\n * ```ts\n * const reqLogger = logger.child({ requestId: req.id });\n * reqLogger.info('Processing request');\n * ```\n */\nexport function createRequestLogger(requestId: string, userId?: string) {\n  return logger.child({\n    requestId,\n    ...(userId && { userId }),\n  });\n}\n"],"names":[],"mappings":";;;;;;AAAA;AACA;;;AAEA;;;;;;;;;;;;;;;;;;;;CAoBC,GAED,oDAAoD;AACpD,MAAM,WACJ,QAAQ,GAAG,CAAC,SAAS,IAAI,CAAC,yIAAG,CAAC,QAAQ,KAAK,eAAe,SAAS,OAAO;AAErE,MAAM,SAAS,IAAA,4GAAI,EAAC;IACzB,OAAO;IAEP,oCAAoC;IACpC,QAAQ;QACN,OAAO;YACL;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;SACD;QACD,QAAQ;IACV;IAEA,8CAA8C;IAC9C,YAAY;QACV,OAAO,CAAC,QAAU,CAAC;gBAAE,OAAO;YAAM,CAAC;IACrC;IAEA,mDAAmD;IACnD,GAAI,yIAAG,CAAC,QAAQ,KAAK,iBAAiB;QACpC,WAAW;YACT,QAAQ;YACR,SAAS;gBACP,UAAU;gBACV,eAAe;gBACf,QAAQ;YACV;QACF;IACF,CAAC;AACH;AAWO,SAAS,oBAAoB,SAAiB,EAAE,MAAe;IACpE,OAAO,OAAO,KAAK,CAAC;QAClB;QACA,GAAI,UAAU;YAAE;QAAO,CAAC;IAC1B;AACF"}},
    {"offset": {"line": 269, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tucke/Repositories/EFT-Tracker/apps/web/src/lib/security-logger.ts"],"sourcesContent":["import { prisma } from \"./prisma\";\nimport { logger } from \"./logger\";\nimport crypto from \"crypto\";\nimport type { SecurityEventType } from \"@prisma/client\";\n\ninterface SecurityEventData {\n  type: SecurityEventType;\n  userId?: string;\n  email?: string;\n  ipAddress: string;\n  userAgent?: string;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Log a security event to the database\n * Automatically hashes email addresses for privacy\n * Triggers alerts for suspicious activity\n */\nexport async function logSecurityEvent(data: SecurityEventData) {\n  try {\n    // Hash email for privacy (can still correlate events without storing PII)\n    const emailHash = data.email\n      ? crypto.createHash(\"sha256\").update(data.email).digest(\"hex\")\n      : undefined;\n\n    await prisma.securityEvent.create({\n      data: {\n        type: data.type,\n        userId: data.userId,\n        ipAddress: data.ipAddress,\n        userAgent: data.userAgent,\n        metadata: {\n          ...data.metadata,\n          emailHash,\n        },\n      },\n    });\n\n    // Check for suspicious activity patterns\n    if (data.type === \"LOGIN_FAILED\") {\n      await checkFailedLoginThreshold(data.ipAddress);\n    }\n\n    if (data.type === \"RATE_LIMIT_EXCEEDED\") {\n      await checkRateLimitPattern(data.ipAddress);\n    }\n  } catch (error) {\n    // Don't fail the request if logging fails\n    logger.error(\n      { error, eventType: data.type },\n      \"Failed to log security event\"\n    );\n  }\n}\n\n/**\n * Check if an IP has exceeded the failed login threshold\n * Alert if >10 failed logins in the last hour\n */\nasync function checkFailedLoginThreshold(ipAddress: string) {\n  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);\n\n  const failedAttempts = await prisma.securityEvent.count({\n    where: {\n      type: \"LOGIN_FAILED\",\n      ipAddress,\n      createdAt: { gte: oneHourAgo },\n    },\n  });\n\n  if (failedAttempts >= 10) {\n    logger.warn(\n      { ipAddress, failedAttempts },\n      \"Suspicious login activity detected - possible brute force attack\"\n    );\n  }\n}\n\n/**\n * Check if an IP is repeatedly hitting rate limits\n * Alert if >5 rate limit violations in 15 minutes\n */\nasync function checkRateLimitPattern(ipAddress: string) {\n  const fifteenMinutesAgo = new Date(Date.now() - 15 * 60 * 1000);\n\n  const rateLimitHits = await prisma.securityEvent.count({\n    where: {\n      type: \"RATE_LIMIT_EXCEEDED\",\n      ipAddress,\n      createdAt: { gte: fifteenMinutesAgo },\n    },\n  });\n\n  if (rateLimitHits >= 5) {\n    logger.warn(\n      { ipAddress, rateLimitHits },\n      \"Repeated rate limit violations - possible automated attack\"\n    );\n  }\n}\n\n/**\n * Get security events for a user (for security dashboard)\n */\nexport async function getUserSecurityEvents(userId: string, limit = 50) {\n  return prisma.securityEvent.findMany({\n    where: { userId },\n    orderBy: { createdAt: \"desc\" },\n    take: limit,\n  });\n}\n\n/**\n * Get security events for an IP address (for investigation)\n */\nexport async function getIpSecurityEvents(ipAddress: string, limit = 50) {\n  return prisma.securityEvent.findMany({\n    where: { ipAddress },\n    orderBy: { createdAt: \"desc\" },\n    take: limit,\n  });\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;;;;;;;;AAiBO,eAAe,iBAAiB,IAAuB;IAC5D,IAAI;QACF,0EAA0E;QAC1E,MAAM,YAAY,KAAK,KAAK,GACxB,gHAAM,CAAC,UAAU,CAAC,UAAU,MAAM,CAAC,KAAK,KAAK,EAAE,MAAM,CAAC,SACtD;QAEJ,MAAM,+IAAM,CAAC,aAAa,CAAC,MAAM,CAAC;YAChC,MAAM;gBACJ,MAAM,KAAK,IAAI;gBACf,QAAQ,KAAK,MAAM;gBACnB,WAAW,KAAK,SAAS;gBACzB,WAAW,KAAK,SAAS;gBACzB,UAAU;oBACR,GAAG,KAAK,QAAQ;oBAChB;gBACF;YACF;QACF;QAEA,yCAAyC;QACzC,IAAI,KAAK,IAAI,KAAK,gBAAgB;YAChC,MAAM,0BAA0B,KAAK,SAAS;QAChD;QAEA,IAAI,KAAK,IAAI,KAAK,uBAAuB;YACvC,MAAM,sBAAsB,KAAK,SAAS;QAC5C;IACF,EAAE,OAAO,OAAO;QACd,0CAA0C;QAC1C,+IAAM,CAAC,KAAK,CACV;YAAE;YAAO,WAAW,KAAK,IAAI;QAAC,GAC9B;IAEJ;AACF;AAEA;;;CAGC,GACD,eAAe,0BAA0B,SAAiB;IACxD,MAAM,aAAa,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK;IAEnD,MAAM,iBAAiB,MAAM,+IAAM,CAAC,aAAa,CAAC,KAAK,CAAC;QACtD,OAAO;YACL,MAAM;YACN;YACA,WAAW;gBAAE,KAAK;YAAW;QAC/B;IACF;IAEA,IAAI,kBAAkB,IAAI;QACxB,+IAAM,CAAC,IAAI,CACT;YAAE;YAAW;QAAe,GAC5B;IAEJ;AACF;AAEA;;;CAGC,GACD,eAAe,sBAAsB,SAAiB;IACpD,MAAM,oBAAoB,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,KAAK;IAE1D,MAAM,gBAAgB,MAAM,+IAAM,CAAC,aAAa,CAAC,KAAK,CAAC;QACrD,OAAO;YACL,MAAM;YACN;YACA,WAAW;gBAAE,KAAK;YAAkB;QACtC;IACF;IAEA,IAAI,iBAAiB,GAAG;QACtB,+IAAM,CAAC,IAAI,CACT;YAAE;YAAW;QAAc,GAC3B;IAEJ;AACF;AAKO,eAAe,sBAAsB,MAAc,EAAE,QAAQ,EAAE;IACpE,OAAO,+IAAM,CAAC,aAAa,CAAC,QAAQ,CAAC;QACnC,OAAO;YAAE;QAAO;QAChB,SAAS;YAAE,WAAW;QAAO;QAC7B,MAAM;IACR;AACF;AAKO,eAAe,oBAAoB,SAAiB,EAAE,QAAQ,EAAE;IACrE,OAAO,+IAAM,CAAC,aAAa,CAAC,QAAQ,CAAC;QACnC,OAAO;YAAE;QAAU;QACnB,SAAS;YAAE,WAAW;QAAO;QAC7B,MAAM;IACR;AACF"}},
    {"offset": {"line": 389, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tucke/Repositories/EFT-Tracker/apps/web/src/lib/auth.ts"],"sourcesContent":["import NextAuth from \"next-auth\";\nimport Credentials from \"next-auth/providers/credentials\";\nimport bcrypt from \"bcryptjs\";\nimport { prisma } from \"./prisma\";\nimport { logSecurityEvent } from \"./security-logger\";\n\nexport const { handlers, signIn, signOut, auth } = NextAuth({\n  trustHost: true,\n  providers: [\n    Credentials({\n      name: \"credentials\",\n      credentials: {\n        email: { label: \"Email\", type: \"email\" },\n        password: { label: \"Password\", type: \"password\" },\n      },\n      async authorize(credentials, request) {\n        if (!credentials?.email || !credentials?.password) {\n          return null;\n        }\n\n        const email = credentials.email as string;\n        const password = credentials.password as string;\n\n        // Get IP and user agent from request\n        const ipAddress =\n          request?.headers?.get(\"x-forwarded-for\") ||\n          request?.headers?.get(\"x-real-ip\") ||\n          \"unknown\";\n        const userAgent = request?.headers?.get(\"user-agent\") ?? undefined;\n\n        const user = await prisma.user.findUnique({\n          where: { email },\n        });\n\n        if (!user) {\n          // Log failed login - user not found\n          await logSecurityEvent({\n            type: \"LOGIN_FAILED\",\n            email,\n            ipAddress,\n            userAgent,\n            metadata: { reason: \"user_not_found\" },\n          });\n          return null;\n        }\n\n        const passwordMatch = await bcrypt.compare(password, user.password);\n\n        if (!passwordMatch) {\n          // Log failed login - invalid password\n          await logSecurityEvent({\n            type: \"LOGIN_FAILED\",\n            userId: user.id,\n            email,\n            ipAddress,\n            userAgent,\n            metadata: { reason: \"invalid_password\" },\n          });\n          return null;\n        }\n\n        // Log successful login\n        await logSecurityEvent({\n          type: \"LOGIN_SUCCESS\",\n          userId: user.id,\n          email,\n          ipAddress,\n          userAgent,\n        });\n\n        return {\n          id: user.id,\n          email: user.email,\n          name: user.name,\n        };\n      },\n    }),\n  ],\n  session: {\n    strategy: \"jwt\",\n  },\n  pages: {\n    signIn: \"/login\",\n  },\n  callbacks: {\n    async jwt({ token, user }) {\n      if (user) {\n        token.id = user.id;\n      }\n      return token;\n    },\n    async session({ session, token }) {\n      if (session.user) {\n        session.user.id = token.id as string;\n      }\n      return session;\n    },\n  },\n});\n"],"names":[],"mappings":";;;;;;;;;;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;;;;;;;;AAEO,MAAM,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,IAAA,8QAAQ,EAAC;IAC1D,WAAW;IACX,WAAW;QACT,IAAA,mOAAW,EAAC;YACV,MAAM;YACN,aAAa;gBACX,OAAO;oBAAE,OAAO;oBAAS,MAAM;gBAAQ;gBACvC,UAAU;oBAAE,OAAO;oBAAY,MAAM;gBAAW;YAClD;YACA,MAAM,WAAU,WAAW,EAAE,OAAO;gBAClC,IAAI,CAAC,aAAa,SAAS,CAAC,aAAa,UAAU;oBACjD,OAAO;gBACT;gBAEA,MAAM,QAAQ,YAAY,KAAK;gBAC/B,MAAM,WAAW,YAAY,QAAQ;gBAErC,qCAAqC;gBACrC,MAAM,YACJ,SAAS,SAAS,IAAI,sBACtB,SAAS,SAAS,IAAI,gBACtB;gBACF,MAAM,YAAY,SAAS,SAAS,IAAI,iBAAiB;gBAEzD,MAAM,OAAO,MAAM,+IAAM,CAAC,IAAI,CAAC,UAAU,CAAC;oBACxC,OAAO;wBAAE;oBAAM;gBACjB;gBAEA,IAAI,CAAC,MAAM;oBACT,oCAAoC;oBACpC,MAAM,IAAA,qKAAgB,EAAC;wBACrB,MAAM;wBACN;wBACA;wBACA;wBACA,UAAU;4BAAE,QAAQ;wBAAiB;oBACvC;oBACA,OAAO;gBACT;gBAEA,MAAM,gBAAgB,MAAM,mMAAM,CAAC,OAAO,CAAC,UAAU,KAAK,QAAQ;gBAElE,IAAI,CAAC,eAAe;oBAClB,sCAAsC;oBACtC,MAAM,IAAA,qKAAgB,EAAC;wBACrB,MAAM;wBACN,QAAQ,KAAK,EAAE;wBACf;wBACA;wBACA;wBACA,UAAU;4BAAE,QAAQ;wBAAmB;oBACzC;oBACA,OAAO;gBACT;gBAEA,uBAAuB;gBACvB,MAAM,IAAA,qKAAgB,EAAC;oBACrB,MAAM;oBACN,QAAQ,KAAK,EAAE;oBACf;oBACA;oBACA;gBACF;gBAEA,OAAO;oBACL,IAAI,KAAK,EAAE;oBACX,OAAO,KAAK,KAAK;oBACjB,MAAM,KAAK,IAAI;gBACjB;YACF;QACF;KACD;IACD,SAAS;QACP,UAAU;IACZ;IACA,OAAO;QACL,QAAQ;IACV;IACA,WAAW;QACT,MAAM,KAAI,EAAE,KAAK,EAAE,IAAI,EAAE;YACvB,IAAI,MAAM;gBACR,MAAM,EAAE,GAAG,KAAK,EAAE;YACpB;YACA,OAAO;QACT;QACA,MAAM,SAAQ,EAAE,OAAO,EAAE,KAAK,EAAE;YAC9B,IAAI,QAAQ,IAAI,EAAE;gBAChB,QAAQ,IAAI,CAAC,EAAE,GAAG,MAAM,EAAE;YAC5B;YACA,OAAO;QACT;IACF;AACF"}},
    {"offset": {"line": 514, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tucke/Repositories/EFT-Tracker/apps/web/src/lib/quest-status.ts"],"sourcesContent":["/**\n * Quest Status Computation Utility\n *\n * Computes the effective quest status based on stored status and objective progress.\n * This is used to determine IN_PROGRESS status when some objectives are done.\n */\n\nimport type { QuestStatus } from \"@prisma/client\";\n\nexport interface ObjectiveWithProgress {\n  id: string;\n  optional: boolean;\n  count?: number | null; // Target count from Objective (for numeric objectives)\n  progress?:\n    | { completed: boolean; current?: number | null; target?: number | null }[]\n    | null;\n}\n\nexport interface ObjectiveProgressSummary {\n  total: number;\n  completed: number;\n  requiredTotal: number;\n  requiredCompleted: number;\n}\n\n/**\n * Check if an objective is complete.\n * For numeric objectives (with target), checks if current >= target.\n * For binary objectives, checks the completed flag.\n */\nexport function isObjectiveComplete(\n  progress:\n    | { completed: boolean; current?: number | null; target?: number | null }\n    | null\n    | undefined\n): boolean {\n  if (!progress) return false;\n\n  // For numeric objectives, check current >= target\n  if (\n    progress.target !== null &&\n    progress.target !== undefined &&\n    progress.target > 0\n  ) {\n    const current = progress.current ?? 0;\n    return current >= progress.target;\n  }\n\n  // For binary objectives, use the completed flag\n  return progress.completed === true;\n}\n\n/**\n * Compute objective progress summary for a quest.\n * Returns counts of total and completed objectives, separated by required vs optional.\n */\nexport function computeObjectiveProgress(\n  objectives: ObjectiveWithProgress[]\n): ObjectiveProgressSummary {\n  let total = 0;\n  let completed = 0;\n  let requiredTotal = 0;\n  let requiredCompleted = 0;\n\n  for (const obj of objectives) {\n    total++;\n    const isComplete = isObjectiveComplete(obj.progress?.[0]);\n\n    if (isComplete) {\n      completed++;\n    }\n\n    if (!obj.optional) {\n      requiredTotal++;\n      if (isComplete) {\n        requiredCompleted++;\n      }\n    }\n  }\n\n  return { total, completed, requiredTotal, requiredCompleted };\n}\n\n/**\n * Compute the effective quest status based on stored status and objective progress.\n *\n * Rules:\n * - If stored status is LOCKED, always return LOCKED (dependencies not met)\n * - If all required objectives are complete, return COMPLETED\n * - If at least one required objective is complete, return IN_PROGRESS\n * - Otherwise, return the stored status (AVAILABLE or computed default)\n *\n * @param storedStatus - The status stored in QuestProgress (or null if no progress)\n * @param objectives - Array of objectives with their progress\n * @param defaultStatus - Status to use when no progress exists (default: \"AVAILABLE\")\n */\nexport function computeQuestStatus(\n  storedStatus: QuestStatus | null,\n  objectives: ObjectiveWithProgress[],\n  defaultStatus: QuestStatus = \"AVAILABLE\"\n): QuestStatus {\n  // If locked, stay locked - dependencies take precedence\n  if (storedStatus === \"LOCKED\") {\n    return \"LOCKED\";\n  }\n\n  // If no objectives, use stored status or default\n  if (objectives.length === 0) {\n    return storedStatus ?? defaultStatus;\n  }\n\n  const { requiredTotal, requiredCompleted } =\n    computeObjectiveProgress(objectives);\n\n  // If no required objectives, treat all objectives as required\n  const effectiveTotal = requiredTotal > 0 ? requiredTotal : objectives.length;\n  const effectiveCompleted =\n    requiredTotal > 0\n      ? requiredCompleted\n      : objectives.filter((o) => isObjectiveComplete(o.progress?.[0])).length;\n\n  // All required objectives complete -> COMPLETED\n  if (effectiveCompleted >= effectiveTotal && effectiveTotal > 0) {\n    return \"COMPLETED\";\n  }\n\n  // Some required objectives complete -> IN_PROGRESS\n  if (effectiveCompleted > 0) {\n    return \"IN_PROGRESS\";\n  }\n\n  // No objectives complete, use stored status or default\n  return storedStatus ?? defaultStatus;\n}\n\n/**\n * Check if a quest should auto-complete based on objective progress.\n * Returns true if all required objectives are marked as complete.\n * For numeric objectives, checks if current >= target.\n */\nexport function shouldAutoCompleteQuest(\n  objectives: ObjectiveWithProgress[]\n): boolean {\n  if (objectives.length === 0) {\n    return false; // Can't auto-complete a quest with no objectives\n  }\n\n  const requiredObjectives = objectives.filter((o) => !o.optional);\n\n  // If no required objectives, all objectives must be complete\n  const targetObjectives =\n    requiredObjectives.length > 0 ? requiredObjectives : objectives;\n\n  return targetObjectives.every((o) => isObjectiveComplete(o.progress?.[0]));\n}\n\n/**\n * Determine if completing/uncompleting an objective would change the quest status.\n * Useful for deciding whether to trigger auto-unlock logic.\n */\nexport function wouldObjectiveChangeQuestStatus(\n  currentStatus: QuestStatus,\n  objectives: ObjectiveWithProgress[],\n  objectiveId: string,\n  newCompletedValue: boolean,\n  newCurrent?: number | null,\n  newTarget?: number | null\n): { wouldChange: boolean; newStatus: QuestStatus } {\n  // Create a copy of objectives with the updated progress\n  const updatedObjectives = objectives.map((obj) => {\n    if (obj.id === objectiveId) {\n      return {\n        ...obj,\n        progress: [\n          {\n            completed: newCompletedValue,\n            current: newCurrent ?? null,\n            target: newTarget ?? null,\n          },\n        ],\n      };\n    }\n    return obj;\n  });\n\n  const newStatus = computeQuestStatus(currentStatus, updatedObjectives);\n  return {\n    wouldChange: newStatus !== currentStatus,\n    newStatus,\n  };\n}\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;;;;;AAyBM,SAAS,oBACd,QAGa;IAEb,IAAI,CAAC,UAAU,OAAO;IAEtB,kDAAkD;IAClD,IACE,SAAS,MAAM,KAAK,QACpB,SAAS,MAAM,KAAK,aACpB,SAAS,MAAM,GAAG,GAClB;QACA,MAAM,UAAU,SAAS,OAAO,IAAI;QACpC,OAAO,WAAW,SAAS,MAAM;IACnC;IAEA,gDAAgD;IAChD,OAAO,SAAS,SAAS,KAAK;AAChC;AAMO,SAAS,yBACd,UAAmC;IAEnC,IAAI,QAAQ;IACZ,IAAI,YAAY;IAChB,IAAI,gBAAgB;IACpB,IAAI,oBAAoB;IAExB,KAAK,MAAM,OAAO,WAAY;QAC5B;QACA,MAAM,aAAa,oBAAoB,IAAI,QAAQ,EAAE,CAAC,EAAE;QAExD,IAAI,YAAY;YACd;QACF;QAEA,IAAI,CAAC,IAAI,QAAQ,EAAE;YACjB;YACA,IAAI,YAAY;gBACd;YACF;QACF;IACF;IAEA,OAAO;QAAE;QAAO;QAAW;QAAe;IAAkB;AAC9D;AAeO,SAAS,mBACd,YAAgC,EAChC,UAAmC,EACnC,gBAA6B,WAAW;IAExC,wDAAwD;IACxD,IAAI,iBAAiB,UAAU;QAC7B,OAAO;IACT;IAEA,iDAAiD;IACjD,IAAI,WAAW,MAAM,KAAK,GAAG;QAC3B,OAAO,gBAAgB;IACzB;IAEA,MAAM,EAAE,aAAa,EAAE,iBAAiB,EAAE,GACxC,yBAAyB;IAE3B,8DAA8D;IAC9D,MAAM,iBAAiB,gBAAgB,IAAI,gBAAgB,WAAW,MAAM;IAC5E,MAAM,qBACJ,gBAAgB,IACZ,oBACA,WAAW,MAAM,CAAC,CAAC,IAAM,oBAAoB,EAAE,QAAQ,EAAE,CAAC,EAAE,GAAG,MAAM;IAE3E,gDAAgD;IAChD,IAAI,sBAAsB,kBAAkB,iBAAiB,GAAG;QAC9D,OAAO;IACT;IAEA,mDAAmD;IACnD,IAAI,qBAAqB,GAAG;QAC1B,OAAO;IACT;IAEA,uDAAuD;IACvD,OAAO,gBAAgB;AACzB;AAOO,SAAS,wBACd,UAAmC;IAEnC,IAAI,WAAW,MAAM,KAAK,GAAG;QAC3B,OAAO,OAAO,iDAAiD;IACjE;IAEA,MAAM,qBAAqB,WAAW,MAAM,CAAC,CAAC,IAAM,CAAC,EAAE,QAAQ;IAE/D,6DAA6D;IAC7D,MAAM,mBACJ,mBAAmB,MAAM,GAAG,IAAI,qBAAqB;IAEvD,OAAO,iBAAiB,KAAK,CAAC,CAAC,IAAM,oBAAoB,EAAE,QAAQ,EAAE,CAAC,EAAE;AAC1E;AAMO,SAAS,gCACd,aAA0B,EAC1B,UAAmC,EACnC,WAAmB,EACnB,iBAA0B,EAC1B,UAA0B,EAC1B,SAAyB;IAEzB,wDAAwD;IACxD,MAAM,oBAAoB,WAAW,GAAG,CAAC,CAAC;QACxC,IAAI,IAAI,EAAE,KAAK,aAAa;YAC1B,OAAO;gBACL,GAAG,GAAG;gBACN,UAAU;oBACR;wBACE,WAAW;wBACX,SAAS,cAAc;wBACvB,QAAQ,aAAa;oBACvB;iBACD;YACH;QACF;QACA,OAAO;IACT;IAEA,MAAM,YAAY,mBAAmB,eAAe;IACpD,OAAO;QACL,aAAa,cAAc;QAC3B;IACF;AACF"}},
    {"offset": {"line": 628, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/tucke/Repositories/EFT-Tracker/apps/web/src/app/api/quests/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { prisma } from \"@/lib/prisma\";\nimport { auth } from \"@/lib/auth\";\nimport { Prisma } from \"@prisma/client\";\nimport { logger } from \"@/lib/logger\";\nimport {\n  computeQuestStatus,\n  computeObjectiveProgress,\n  type ObjectiveWithProgress,\n} from \"@/lib/quest-status\";\n\ntype QuestWithRelations = Prisma.QuestGetPayload<{\n  include: {\n    trader: true;\n    objectives: {\n      include: {\n        progress: true;\n      };\n    };\n    dependsOn: {\n      include: {\n        requiredQuest: {\n          include: {\n            trader: true;\n            progress: true;\n          };\n        };\n      };\n    };\n    dependedOnBy: {\n      include: {\n        dependentQuest: {\n          include: {\n            trader: true;\n          };\n        };\n      };\n    };\n    progress: true;\n  };\n}>;\n\n/**\n * Check if a dependency requirement is satisfied based on the required status types\n * and the actual progress status.\n */\nfunction isDependencyMet(\n  requirementStatus: string[],\n  actualStatus: string | null\n): boolean {\n  if (!actualStatus) return false;\n\n  const normalizedActual = actualStatus.toUpperCase();\n\n  for (const reqStatus of requirementStatus) {\n    const normalizedReq = reqStatus.toLowerCase();\n\n    if (normalizedReq === \"complete\" && normalizedActual === \"COMPLETED\") {\n      return true;\n    }\n    if (\n      normalizedReq === \"active\" &&\n      (normalizedActual === \"IN_PROGRESS\" || normalizedActual === \"COMPLETED\")\n    ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Recursively check if a quest should be locked based on its dependency chain.\n * This handles the case where a prerequisite quest has stored progress \"COMPLETED\"\n * but should actually be locked because ITS prerequisites are not met.\n *\n * Uses memoization to avoid redundant computation.\n */\nfunction isQuestEffectivelyLocked(\n  questId: string,\n  quests: QuestWithRelations[],\n  memo: Map<string, boolean>\n): boolean {\n  // Check memo first\n  if (memo.has(questId)) {\n    return memo.get(questId)!;\n  }\n\n  const quest = quests.find((q) => q.id === questId);\n  if (!quest) {\n    // Quest not in results (filtered out), assume not locked\n    memo.set(questId, false);\n    return false;\n  }\n\n  // If no dependencies, quest is not locked - it's available to start\n  // (The actual status will come from stored progress or default to \"available\")\n  if (quest.dependsOn.length === 0) {\n    memo.set(questId, false);\n    return false;\n  }\n\n  // Check each dependency\n  for (const dep of quest.dependsOn) {\n    const depQuest = quests.find((q) => q.id === dep.requiredQuest.id);\n    const requirementStatus = dep.requirementStatus || [\"complete\"];\n\n    // Get progress status - prefer from filtered results, fall back to dependency data\n    // This is important when searching/filtering: the dependency quest may not be in\n    // the filtered results, but we still have its progress via the dependsOn relation\n    let storedStatus: string | null = null;\n    if (depQuest) {\n      storedStatus = depQuest.progress?.[0]?.status || null;\n    } else {\n      // Quest not in filtered results - use progress from dependency relation\n      // The requiredQuest now includes progress data for the current user\n      const reqQuestProgress = (\n        dep.requiredQuest as { progress?: { status: string }[] }\n      ).progress;\n      storedStatus = reqQuestProgress?.[0]?.status || null;\n    }\n\n    // First check: Is the stored status sufficient?\n    if (!isDependencyMet(requirementStatus, storedStatus)) {\n      // Stored status doesn't meet requirement\n      memo.set(questId, true);\n      return true;\n    }\n\n    // Second check: Even if stored status is COMPLETED/IN_PROGRESS,\n    // is the prerequisite quest effectively locked due to its own dependencies?\n    // Only do this recursive check if the quest is in the filtered results\n    // (we can't check deeper dependencies if the quest isn't loaded)\n    if (\n      depQuest &&\n      isQuestEffectivelyLocked(dep.requiredQuest.id, quests, memo)\n    ) {\n      // The prerequisite is effectively locked, so this dependency is not truly met\n      memo.set(questId, true);\n      return true;\n    }\n  }\n\n  // All dependencies are met\n  memo.set(questId, false);\n  return false;\n}\n\nasync function handleGET(request: Request) {\n  try {\n    const { searchParams } = new URL(request.url);\n    const kappa = searchParams.get(\"kappa\");\n    const search = searchParams.get(\"search\");\n\n    // Get current user session for progress\n    const session = await auth();\n    const userId = session?.user?.id;\n\n    // Build where clause\n    const where: Record<string, unknown> = {};\n\n    if (kappa === \"true\") {\n      where.kappaRequired = true;\n    }\n\n    if (search) {\n      where.title = {\n        contains: search,\n        mode: \"insensitive\",\n      };\n    }\n\n    // Fetch quests with related data including objective progress\n    const quests = await prisma.quest.findMany({\n      where,\n      include: {\n        trader: true,\n        objectives: {\n          include: {\n            progress: userId\n              ? {\n                  where: { userId },\n                }\n              : false,\n          },\n        },\n        dependsOn: {\n          include: {\n            requiredQuest: {\n              include: {\n                trader: true,\n                progress: userId\n                  ? {\n                      where: { userId },\n                    }\n                  : false,\n              },\n            },\n          },\n        },\n        dependedOnBy: {\n          include: {\n            dependentQuest: {\n              include: {\n                trader: true,\n              },\n            },\n          },\n        },\n        progress: userId\n          ? {\n              where: { userId },\n            }\n          : false,\n      },\n      orderBy: [{ levelRequired: \"asc\" }, { title: \"asc\" }],\n    });\n\n    // Memoization map for recursive dependency checking\n    const lockMemo = new Map<string, boolean>();\n\n    // Transform to include computed status and objective progress summary\n    const questsWithStatus = quests.map((quest: QuestWithRelations) => {\n      const progress = quest.progress?.[0] || null;\n\n      // Use recursive function to check if quest should be locked\n      // This properly handles chains where a prerequisite has \"COMPLETED\" stored\n      // but should actually be locked due to its own unmet dependencies\n      const shouldBeLocked = isQuestEffectivelyLocked(\n        quest.id,\n        quests,\n        lockMemo\n      );\n\n      // Convert objectives to ObjectiveWithProgress format\n      const objectivesWithProgress: ObjectiveWithProgress[] =\n        quest.objectives.map((obj) => ({\n          id: obj.id,\n          optional: obj.optional,\n          progress: obj.progress || [],\n        }));\n\n      // Compute objective progress summary\n      const objectivesSummary = computeObjectiveProgress(\n        objectivesWithProgress\n      );\n\n      // Determine base status considering dependencies\n      let baseStatus = progress?.status ?? null;\n      if (shouldBeLocked) {\n        baseStatus = \"LOCKED\";\n      }\n\n      // Compute final status considering objective progress\n      const computedStatus = computeQuestStatus(\n        baseStatus,\n        objectivesWithProgress,\n        shouldBeLocked ? \"LOCKED\" : \"AVAILABLE\"\n      ).toLowerCase();\n\n      return {\n        ...quest,\n        progress,\n        computedStatus,\n        objectivesSummary,\n      };\n    });\n\n    return NextResponse.json({\n      quests: questsWithStatus,\n      total: questsWithStatus.length,\n    });\n  } catch (error) {\n    logger.error({ err: error }, \"Error fetching quests\");\n    return NextResponse.json(\n      { error: \"Failed to fetch quests\" },\n      { status: 500 }\n    );\n  }\n}\n\n// Note: Rate limiting removed for read-only public data endpoint\n// Public quest information should be freely accessible without limits\nexport const GET = handleGET;\n"],"names":[],"mappings":"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"}}]
}